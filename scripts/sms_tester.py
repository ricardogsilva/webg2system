#!/usr/bin/env python
#-*- coding: utf-8 -*-

"""
&manual
This script will become the SMS testing script for the new g2system.
&end
"""

# TODO

import os
import re
import glob
import subprocess
import logging
import logging.handlers
import socket
import datetime as dt
import sys
from urllib import urlencode
from urllib2 import Request, urlopen, URLError

sys.path.append("&PYTHONLIBDIR&")


def initialize():
    '''
    Initialize the running environment with some SMS variables.

    The SMS variables are inserted by the SMS pre-processor at
    runtime, by replacing the strings that are marked with leading
    and trailing '&' characters. After the SMS variables are put into
    the running environment, the external 'smsinit' program is called,
    in order to let the SMS server that a new task has been started.
    '''

    # SMS variables that are going to be substituted by the preprocessor
    os.environ["SMS_PROG"] = "&SMS_PROG&"
    os.environ["SMSNODE"] = "&SMSNODE&"
    os.environ["SMSNAME"] = "&SMSNAME&"
    os.environ["SMSPASS"] = "&SMSPASS&"
    os.environ["SMSTRYNO"] = "&SMSTRYNO&"
    #os.environ["PATH"] = os.environ["PATH"] + ":/home/sms/bin"
    os.environ["PATH"] = os.environ["PATH"] + ":&SMSCOMMANDSDIR&"

    # get the SMS variable that defines the list of e-mails to be warned 
    mailList = "&MAIL_LIST&".replace(" ", "").split(",")

    # create the logger
    logger = create_logger(mailList)

    # Tell SMS we have started
    # The SMS variable SMSRID will be set to parameter of smsinit
    # Here we give the current PID.
    subprocess.call(["smsinit", str(os.getpid())])

def create_logger(mailList, logLevel="&LOG_LEVEL&"):
    """Create the logger object."""
         
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)
    # one handler for saving messages to file, another for
    # outputing to the console and one more for sending e-mail alerts
    logDir = "/&LOGS_DIR&/&FAMILY&/&TASK&"
    if not os.path.isdir(logDir):
        os.makedirs(logDir)
    today = dt.datetime.utcnow().strftime("%Y%m%d")
    logFile = "%s/&TASK&_%s.log" % (logDir, today)
    logFileHandler = logging.FileHandler(logFile)
    logFileHandler.setLevel(logging.DEBUG)
    logConsoleHandler = logging.StreamHandler()
    logConsoleHandler.setLevel(eval("logging.%s" % (logLevel.upper())))
    hostname = socket.gethostname()
    sender = "%s@retrieval.system" % (hostname)
    mail_host = "eris.meteo.pt"
    logMailHandler = logging.handlers.SMTPHandler(mail_host, sender,
            mailList, "SMS: &SMSNODE&/&SUITE&/&FAMILY&/&TASK& error")
    logMailHandler.setLevel(logging.ERROR)
    # formatters 
    logFileFormatter = logging.Formatter("%(asctime)s - %(name)s" \
            " %(levelname)s - %(message)s")
    logConsoleFormatter = logging.Formatter("%(name)s %(levelname)s" \
            " - %(message)s")
    logMailFormatter = logging.Formatter("%(asctime)s - %(name)s" \
            " %(levelname)s - %(message)s")
    logFileHandler.setFormatter(logFileFormatter)
    logConsoleHandler.setFormatter(logConsoleFormatter)
    logMailHandler.setFormatter(logMailFormatter)
    # add handlers to the logger
    logger.addHandler(logFileHandler)
    logger.addHandler(logConsoleHandler)
    logger.addHandler(logMailHandler)

    # clean up log files older than 15 days:
    logger.debug('clean up log files older than 15 days...')
    cleanUpDateLimit = 15 # time unit in days
    logFilesList = glob.glob("%s/*"%logDir)
    for fileNumber,fileName in enumerate([globResult.rpartition('/')[2] for globResult in logFilesList]):
        fileDate = dt.datetime.strptime((fileName.partition('.')[0]).rpartition('_')[2],"%Y%m%d")
        if fileDate <= dt.datetime.utcnow()-dt.timedelta(days=cleanUpDateLimit):
            logger.debug("delete file: %s"%logFilesList[fileNumber])
            os.remove(logFilesList[fileNumber])

    return logger

def sms_label(msg, name="info", logger=logging.getLogger(), logMsg=True, logLevel=None):
    if logMsg:
        if logLevel is not None:
            eval("logger.%s(msg)" % logLevel)
        else:
            logger.info(msg)
    newProcess = subprocess.Popen(["smslabel", name, str(msg)], stdout=subprocess.PIPE)
    result = newProcess.wait()
    return result

def sms_meter(progress, name="progress"):
    newProcess = subprocess.Popen(["smsmeter", name, str(progress)], stdout=subprocess.PIPE)
    result = newProcess.wait()
    return result

def send_complete():
    subprocess.call(["smscomplete"])

def error(msg, logger=logging.getLogger(), smsLabelObj="info"):
    """An error function to catch any errors generated by the script."""

    errorMessage = "there was an error: %s" % (msg) 
    logger.error(errorMessage)
    sms_label(errorMessage, smsLabelObj, logMsg=False)
    subprocess.call(["smsabort"])
    raise SystemExit

def main():
    # collect SMS variables for this task
    ymd = '&YMD&'
    hour = '&HOUR&'
    codeHost = '&HOSTNAME&'
    username = '&USERNAME&'
    password = '&PASSWORD&'
    force = '&FORCE&'
    package = '&PACKAGE&'
    area = '&AREA&'
    extra = '&EXTRA_KWARGS&'.strip()
    log_level = '&LOG_LEVEL&'

    g2systemURL = 'http://%s/g2system/operations/create/' % codeHost
    values = {
        'package': package,
        'area': area,
        'timeslot': dt.datetime.strptime(ymd + hour, '%Y%m%d%H'),
        'username': username,
        'password': password,
        'force' : force,
        'log_level' : log_level,
        'extra' : extra
    }
    data = urlencode(values)
    headers = {
        'Content-Type' : 'application/x-www-form-urlencoded',
    }
    req = Request(g2systemURL, data=data, headers=headers)
    try:
        response = urlopen(req)
        theResponse = response.read()
        print(theResponse)
        result = get_result(theResponse)
        if not result:
            print('The task did not execute correctly. Check the output and '\
                  'the logs.')
    except URLError, e:
        if hasattr(e, 'reason'):
            print('Failed to reach %s host' % codeHost)
            print('reason: %s' % e.reason)
        elif hasattr(e, 'code'):
            print('The server couldn\'t fulfill the request.')
            print('Error code: %s' % e.code)
        raise 

def get_result(response_text):
    result_pat = re.compile(r'<span id=["\']result["\']>(\w+)</span>')
    re_obj = result_pat.search(response_text)
    result = eval(re_obj.group(1))
    return result

if __name__ == "__main__":
    try:
        initialize()
        main()
        send_complete()
    except Exception, msg:
        error(msg, logger=logging.getLogger())
